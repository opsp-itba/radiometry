# -*- coding: utf-8 -*-
"""simulacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MbNEFBcgxux0fU5BM-dcYlhmLSLaOs4K
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.signal as ss
import scipy as scipy
import matplotlib as mpl
import math
import pandas as pd
from scipy.interpolate import interp1d

df1 = pd.read_csv('Isp.csv')
# Dataset is now stored in a Pandas Dataframe

pd.set_option("display.max_rows", None, "display.max_columns", None)
print(df1)
yHeader = 'Isp'

#Caracteristicas instrumento
x_step = 200e-9 #En m
N = 1000 #Cantidad de samples
lmin_sensor = 800e-9
lmax_sensor = 1600e-9

#Entonces el instrumento tiene: (#d: optical. x:x)
x_range = (N - 1) * x_step
d_step = 2 * x_step 
d_range = 2 * x_range

print('Características Instrumento:')
print('paso x (nm):',x_step*1e9)
print('paso d (nm):',d_step*1e9)
print('distancia (cm):',x_range*1e2)
print('dco (cm):',d_range*1e2)
print('Minima longitud de onda posible (um):',(2*d_step)*1e6)
print('Maximo número de onda posible (cm$^-1$)',1/(2*d_step)*1e-2)

#Caracteristicas input simulación
input_domain_units = 1e-6  #[m], Dominio de entrada en um, data en I/m^2/[um]
N_data = len(np.array(df1['wl']))
lambda_min = df1.at[0, 'wl'] * input_domain_units
lambda_max = df1.at[N_data-1, 'wl'] * input_domain_units
delta_lambda = (df1.at[1, 'wl']-df1.at[0, 'wl']) * input_domain_units
v_max = 1/lambda_min
v_min = 1/lambda_max
print('Data de Entrada:')
print('lambda_min (um):', lambda_min*1e6)
print('lambda_max (um):', lambda_max*1e6)
print('v_max (cm$^{-1}$):', v_max*1e-2)
print('v_min (cm$^{-1}$):', v_min*1e-2)
# plt.figure(1)
# plt.plot(np.array(df1['wl']),np.array(df1[yHeader]))
# plt.title('Data de entrada')
# plt.xlabel('Longitud de Onda (um)')
# plt.ylabel('W/m$^2$/um')

#Características output simulación
output_domain_units = 100 #[m^-1], Dominio de salida en cm^-1, data en W/m^2/[cm^-1]

#Zero Padding en numero de onda para que quede interpolado en d para sampling k*d_step para algun valor de k
k_os_min = 1+int(np.floor(2*d_step*v_max)) #oversampling #ROUND INTEGER TO NEXT INTEGER
print('Oversampling a utilizar:', k_os_min)
v_os = (1/d_step)*k_os_min
v_spec_max = v_os/2 #Frecuencia maxima en el espectro
N2 = int(np.ceil(1+v_spec_max*lambda_max**2/delta_lambda)) #N Calculado con criterio de conservar resolución minima

#Paso en frecuencia
delta_v = v_spec_max / N2 
#Redondear data a bines
v_min = np.ceil(v_min / delta_v) * delta_v  #Redondear v_min a un bin
v_max = np.floor(v_max / delta_v) * delta_v  #Redondear v_max a un bin
#Generar vector de v equiespaciado v_int (numeros enteros, indica múltiplos de delta_v)
v_int = np.linspace(int(v_min/delta_v),int(v_max/delta_v),(int((v_max-v_min)/delta_v)+1))
#(precisión numérica)
v_int = [int(i) for i in np.round(v_int)]

#Entonces
print('N2 (Espectro generado): ', N2)
print('v_min (redondeado a bin, cm$^{-1}$): ', v_min*1e-2)
print('v_max (redondeado a bin, cm$^{-1}$): ', v_max*1e-2)
print('delta_v (paso en número de onda, cm$^{-1}$): ', delta_v*1e-2)

#Calcular longitudes de onda asociadas a numeros de onda para interpolar, en unidades de entrada
v_dom_interp = [ delta_v * i/output_domain_units for i in v_int]  # En unidades de salida
#l_dom_interp = [ 1e4/i for i in v_dom_interp]
l_dom_interp = [1/(input_domain_units*output_domain_units)/i for i in v_dom_interp] #En unidades de entrada
l_original_domain = np.array(df1['wl'])
I_original_data = np.array(df1[yHeader])
#Recortar espectro
I_sensor_data = [0 if (l_original_domain[i]*input_domain_units < lmin_sensor or l_original_domain[i]*input_domain_units > lmax_sensor) else I_original_data[i] for i in range(len(I_original_data))]
I_interp_data_f = interp1d(l_original_domain, I_sensor_data, kind='slinear',fill_value=[0])
I_interp_data = I_interp_data_f(l_dom_interp) #Esta seria la funcion I_data_lambda(1/v)
#Aplicar jacobiano (1/v^2)
#I_v = 1e4 * np.divide(I_interp_data,v_dom_interp)
I_v = 1/(input_domain_units*output_domain_units) * np.divide(I_interp_data,v_dom_interp)
I_v = np.divide(I_v,v_dom_interp)

#Espectro de partida
I = np.zeros(N2)
I[v_int] = I_v
# plt.figure(2)
# plt.plot(I)
# plt.title('Espectro generado a partir de data')
# plt.xlabel('bin')
# plt.ylabel('W/m$^2$/cm$^{-1}$')

#Antitransformar para obtener interferograma de partida
dv = delta_v/output_domain_units  #Diferenciales en output_domain_units, al integrar W/m^2/cm^-1*cm^-1 = W/m^2
I_d = np.fft.irfft(I)*len(I)*dv
print('I_d : ', I_d)
print('i_d length', len(I_d))

#En base al interferograma obtenido, se calculará interferograma simulado
nuevo_id = np.zeros(2 * N)
#VENTANA A UTILIZAR
window = ss.windows.get_window('blackmanharris',2*N)
window2 = np.zeros(2*N)
for i in range(N):
  window2[i] = window[N-1+i+1]
  window2[N-1+i+1] = window[i]
for i in range(int(len(nuevo_id)/2)):
  if i < N2/2:
    nuevo_id[i] = I_d[k_os_min*i]
    nuevo_id[2*N - i - 1] = I_d[k_os_min*(1+i)]
  else:
    #Se utilizaron todos los datos
    #zero padding interpolará valores en frecuencia
    nuevo_id[i] = 0
    nuevo_id[2*N - i - 1] = 0
# APLICAR VENTANA
interferogram_record = np.array(nuevo_id)
interferogram_record = interferogram_record + interferogram_record[0]
for i in range(2*N):
  nuevo_id[i] = nuevo_id[i] * window2[i]

#Interferograma Original
# plt.figure(3)
# plt.plot([i*d_step/k_os_min*1e2 for i in range(int(len(I_d)/2))],[I_d[i]*1e3 for i in range(int(len(I_d)/2))])
# plt.title('Interferograma generado a partir de data')
# plt.xlabel('dco [cm]')
# plt.ylabel('mW/m$^2$')

#Nuevo Interferograma
# plt.figure(5)
# plt.plot([i*d_step*1e2 for i in range(N)],[nuevo_id[i]*1e3 for i in range(N)])
# plt.title('Interferograma ventaneado y resampleado')
# plt.xlabel('dco [cm]')
# plt.ylabel('mW/m$^2$')



#Obtener espectro
dd = d_step
spec = 2*np.absolute(np.fft.rfft(nuevo_id))*dd #TODO: XQ TENGO QUE MULTIPLICAR POR DOS?
#Al integrar, W/m^2*m = W/m^2/m, se busca W/m^2/(output_domain_units)
spec = spec*output_domain_units #Al transformar queda en W/m^2/(m^-1), convertir en W/m^2/(output_domain_units)

v_int_espectro_nuevo = np.linspace(0,len(spec)-1,len(spec))/len(spec)
v_int_espectro_original = np.linspace(0,len(I)-1,len(I))/len(I)

#graficar los dos juntos
plt.figure(6)
plt.plot(v_int_espectro_original*(k_os_min/(d_step*2))*1e-2,I)
plt.title('Espectro Original')
plt.xlabel('número de onda (cm$^{-1}$)')
plt.ylabel('W/m$^2$/cm$^{-1}$')
plt.figure(7)
plt.plot(v_int_espectro_nuevo*(1/(d_step*2))*1e-2,spec)
plt.title('Espectro Obtenido')
plt.xlabel('número de onda (cm$^{-1}$)')
plt.ylabel('W/m$^2$/cm$^{-1}$')
plt.figure(8)
plt.plot(v_int_espectro_original*(k_os_min/(d_step*2))*1e-2,I)
plt.plot(v_int_espectro_nuevo*(1/(d_step*2))*1e-2,spec)
plt.title('Espectros Superpuestos')
plt.xlabel('número de onda (cm$^{-1}$)')
plt.ylabel('W/m$^2$/cm$^{-1}$')
plt.figure(9)
plt.plot(v_int_espectro_original*(k_os_min/(d_step*2))*1e-2,I) #cm^-1
plt.plot(v_int_espectro_nuevo*(1/(d_step*2))*1e-2,spec) #cm^-1
plt.xlim([1e-2/lmax_sensor,1e-2/lmin_sensor])
plt.title('Espectros Superpuestos, recortado')
plt.xlabel('número de onda (cm$^{-1}$)')
plt.ylabel('W/m$^2$/cm$^{-1}$')

plt.figure(10)
plt.plot(v_int_espectro_nuevo*(1/(d_step*2))*1e-2,spec) #cm^-1
plt.xlim([1e-2/lmax_sensor,1e-2/lmin_sensor])
plt.title('Espectros Obtenido, recortado')
plt.xlabel('número de onda (cm$^{-1}$)')
plt.ylabel('W/m$^2$/cm$^{-1}$')

#Graficar ventana utilizada
plt.figure(11)
plt.plot(window)
plt.plot(window2)
plt.title('Ventana utilizada')
plt.xlabel('Dominio (cm)')
plt.ylabel('K')

#Interferogram Record
plt.figure(12)
plt.plot([i*d_step*1e2 for i in range(N)],[interferogram_record[i]*1e3 for i in range(N)])
plt.title('Interferogram Record')
plt.xlabel('dco [cm]')
plt.ylabel('mW/m$^2$')
plt.show()